using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using Microsoft.FSharp.Collections;
using UpdateControls;
using System.Linq;

namespace Strive.DataModel
{
    /// <summary>
    /// Objects stored in this Map need to be immutable to ensure they are not modified externally,
    /// so that all changes are recorded in the history.
    /// History is stored in an ordered map of version to state,
    /// where the state is a map of keys to values.
    /// </summary>
    public class RecordedMapModel<TKeyType, TValueType> : IEnumerable<TValueType>
    {
        private FSharpMap<int, FSharpMap<TKeyType, TValueType>> _history
            = new FSharpMap<int, FSharpMap<TKeyType, TValueType>>(
                Enumerable.Empty<Tuple<int,FSharpMap<TKeyType,TValueType>>>());

        public int CurrentVersion { get; private set; }
        public RecordedMapModel()
        {
            CurrentVersion = -1;
            Clear();
        }

        private FSharpMap<TKeyType, TValueType> Map
        {
            get { return _history.LastOrDefault().Value; }
            set { _history = _history.Add(++CurrentVersion, value); }
        }

        public RecordedMapModel(IEnumerable<KeyValuePair<TKeyType, TValueType>> keyValuePairs) : this()
        {
            Contract.Requires<ArgumentNullException>(keyValuePairs != null);

            foreach (var e in keyValuePairs)
                Map = Map.Add(e.Key, e.Value);
        }

        #region Independent properties
        // Generated by Update Controls --------------------------------
        private readonly Independent _indEntities = new Independent();

        public void Set(TKeyType key, TValueType value)
        {
            _indEntities.OnSet();
            Map = Map.Add(key, value);
        }

        public void Remove(TKeyType key)
        {
            _indEntities.OnSet();
            Map = Map.Remove(key);
        }

        public TValueType Get(TKeyType id)
        {
            _indEntities.OnGet();
            return Map[id];
        }

        public IEnumerable<TValueType> Entities
        {
            get { _indEntities.OnGet(); return Map.Select(x=>x.Value); }
        }

        public int Count
        {
            get { _indEntities.OnGet(); return Map.Count; }
        }

        public void Clear()
        {
            _indEntities.OnSet();
            Map = new FSharpMap<TKeyType, TValueType>(Enumerable.Empty<Tuple<TKeyType, TValueType>>());
        }

        public bool ContainsKey(TKeyType key)
        {
            _indEntities.OnGet();
            return Map.ContainsKey(key);
        }

        // End generated code --------------------------------
        #endregion

        #region IEnumerable<TValueType> Members

        public IEnumerator<TValueType> GetEnumerator()
        {
            return Map.Select(x=>x.Value).GetEnumerator();
        }

        #endregion

        #region IEnumerable Members

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            // TODO: make an extension Values method for FSharpMap?
            return Map.Select(x=>x.Value).GetEnumerator();
        }

        #endregion
    }
}
