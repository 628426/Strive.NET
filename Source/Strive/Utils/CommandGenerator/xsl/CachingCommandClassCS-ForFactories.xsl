<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
	
	<xsl:output method="text" />

	<xsl:template match="/" >
	
						
		// This code is generated by a tool
		
		public class FactoryCommandCache
		{
			private System.Collections.Hashtable _commands = new System.Collections.Hashtable();
			private System.Data.SqlClient.SqlConnection _connection;
			
			// Hide default constructor
			private CommandCache()
			{
			}
			
			/// <summary>
			/// Initialises the CommandCache with a SqlConnection.ConnectionString compatible string
			/// </summary>
			/// <param name="connectionString">The SqlConnection.ConnectionString to use</param>
			/// <remarks>Ths CommandCache will create a new SqlConnection and Open it</remarks>
			public CommandCache(string connectionString)
			{
				_connection = new System.Data.SqlClient.SqlConnection(connectionString);
				_connection.Open();
			}

			/// <summary>
			/// Initialises the CommandCache with a SqlConnection object
			/// </summary>
			/// <param name="connection">The SqlConnection object this CommandCache should use</param>
			/// <remarks>The CommandCache assumes this is an open, valid SqlConnection</remarks>
			public CommandCache(System.Data.SqlClient.SqlConnection connection)
			{
				_connection = connection;

			}

			/// <summary>
			/// Finalises the associated Connection when the CommandCache is finalised
			/// </summary>
			~CommandCache()
			{
				_connection.Close();
			}
			
			private bool isCommandCached(string commandID)
			{
				return _commands.Contains(commandID);
			}
		
	
	<xsl:for-each select="//StoredProcedure">
		<xsl:call-template name="Header">
			<xsl:with-param name="StoredProcedure" select="."/>
		</xsl:call-template>
	
	</xsl:for-each>

		}
	
	</xsl:template>

	<xsl:template name="Header">
		<xsl:param name="StoredProcedure" />
			
			public System.Data.SqlClient.SqlCommand <xsl:value-of select="$StoredProcedure/@name" />
			{
				get
				{
					const string thisID = "<xsl:value-of select="$StoredProcedure/@id" />";
					System.Data.SqlClient.SqlCommand thisCommand;
					if(!this.isCommandCached(thisID))
					{
						// create and add to cache
						thisCommand = new System.Data.SqlClient.SqlCommand();

						thisCommand.Connection = _connection;
						thisCommand.CommandType = System.Data.CommandType.StoredProcedure;
						thisCommand.CommandText = "<xsl:value-of select="$StoredProcedure/@name" />";
						
						// Parameters:
						
						<xsl:call-template name="AddParameters"><xsl:with-param name="Parameters" select="./Parameters" /></xsl:call-template>

						// not sure of the usefullness of this
						// i never really got prepared statements
						thisCommand.Prepare();					
						
						_commands.Add(thisID, thisCommand);
					}
					else
					{
						thisCommand = (System.Data.SqlClient.SqlCommand)this._commands[thisID];
					}
					return thisCommand;
				}
			
			}
	</xsl:template>


	<xsl:template name="HeaderParams">
		<xsl:param name="Parameters" />
		
		<xsl:for-each select="$Parameters/Parameter">
			<xsl:if test="./@output = 'true'">ref </xsl:if><xsl:call-template name="ParameterType"><xsl:with-param name="Parameter" select="."/></xsl:call-template><![CDATA[ ]]><xsl:value-of select="substring-after(./@name,'@')" /><xsl:if test="position() != last()"><![CDATA[, ]]></xsl:if>
		</xsl:for-each>
		
	</xsl:template>
	
	
	<xsl:template name="ParameterType">
		<xsl:param name="Parameter" />System.Data.SqlTypes.<xsl:choose>
								<xsl:when test="contains($Parameter/@type, 'char')">SqlString</xsl:when>
								<xsl:when test="contains($Parameter/@type, 'text')">SqlString</xsl:when>
								<xsl:when test="contains($Parameter/@type, 'int')">SqlInt32</xsl:when>
								<xsl:when test="contains($Parameter/@type, 'binary')">SqlBinary</xsl:when>
								<xsl:otherwise>UNKNOWN<xsl:value-of select="$Parameter/@type" />ThisWontCompileFixXSL</xsl:otherwise>
							</xsl:choose>
	</xsl:template>
	
	<xsl:template name="AddParameters">
		<xsl:param name="Parameters" />
		System.Data.SqlClient.SqlParameter param;
		<xsl:for-each select="$Parameters/Parameter">
					param = new System.Data.SqlClient.SqlParameter();		
					param.ParameterName = "<xsl:value-of select="./@name" />";
					thisCommand.Parameters.Add(param);			
					param = null;
		</xsl:for-each>
	</xsl:template>

</xsl:stylesheet>


  