using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net;
using System.Net.Sockets;
using System.Collections.Concurrent;

using UpdateControls;
using Common.Logging;


namespace Strive.Network.Messages
{
    public enum ConnectionStatus
    {
        Connecting,
        Connected,
        Disconnected
    }

    public class MessageEventArgs : EventArgs
    {
        public IMessage Message { get; private set;}
        public MessageEventArgs(IMessage message) {
            Message = message;
        }
    }

    public class Connection
    {
        private ConnectionStatus _status;

        #region Independent properties
        // Generated by Update Controls --------------------------------
        private Independent _indStatus = new Independent();

        public ConnectionStatus Status
        {
            get { _indStatus.OnGet(); return _status; }
            private set { _indStatus.OnSet(); _status = value; }
        }
        // End generated code --------------------------------
        #endregion

        BlockingCollection<IMessage> messageInQueue;
        BlockingCollection<IMessage> messageOutQueue;

        protected Socket tcpSocket;
        byte[] udpbuffer = new byte[MessageTypeMap.BufferSize];  // Receive buffer.
        byte[] tcpbuffer = new byte[MessageTypeMap.BufferSize];  // Receive buffer.
        int tcpOffset = 0;

        public event EventHandler Connect;
        public event EventHandler ConnectFailed;
        public event EventHandler Disconnect;
        public event EventHandler MessageRecieved;

        protected ILog log;
        public Connection()
        {
            Status = ConnectionStatus.Disconnected;
            log = LogManager.GetCurrentClassLogger();
        }

        public void Start(Socket socket)
        {
            tcpSocket = socket;
            tcpOffset = 0;
            Status = ConnectionStatus.Connected;
            messageInQueue = new BlockingCollection<IMessage>();
            messageOutQueue = new BlockingCollection<IMessage>();
            BeginReading();
            BeginSending();
        }

        public void Start(IPEndPoint remoteEndPoint)
        {
            lock (tcpSocket)
            {
                if (tcpSocket != null) Stop();

                // Connect to the remote endpoint.
                tcpSocket = new Socket(remoteEndPoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
                try
                {
                    tcpSocket.BeginConnect(remoteEndPoint, new AsyncCallback(ConnectTCPCallback), this);
                }
                catch (SocketException se)
                {
                    log.Error("Error connecting, closing connection.", se);
                    Stop();
                    if (ConnectFailed != null) ConnectFailed(this, null);
                    return;
                }

                Status = ConnectionStatus.Connecting;
            }
        }

        public void Stop()
        {
            messageInQueue.CompleteAdding();
            messageOutQueue.CompleteAdding();
            lock (tcpSocket)
            {
                if (tcpSocket != null)
                {
                    if (Status == ConnectionStatus.Connected && Disconnect != null)
                        Disconnect(this, null);

                    try
                    {
                        tcpSocket.Shutdown(SocketShutdown.Both);
                    }
                    catch (SocketException se)
                    {
                        log.Error("Error shutting down", se);
                    }

                    tcpSocket = null;
                }
                Status = ConnectionStatus.Disconnected;
            }
        }

        private static void ConnectTCPCallback(IAsyncResult ar)
        {
            Connection client = (Connection)ar.AsyncState;
            lock (client.tcpSocket)
            {
                try
                {
                    // Complete the connection.
                    client.tcpSocket.EndConnect(ar);
                }
                catch (SocketException se)
                {
                    client.log.Error("Error connecting, closing connection.", se);
                    client.Stop();
                    if (client.ConnectFailed != null) client.ConnectFailed(client, null);
                    return;
                }
                client.log.Info("Connected to " + client.tcpSocket.RemoteEndPoint);
                if (client.Connect != null) client.Connect(client, null);
                client.Start(client.tcpSocket);
            }
        }

        private void BeginReading()
        {
            // Begin reading
            try
            {
                tcpSocket.BeginReceive(tcpbuffer, 0, MessageTypeMap.BufferSize, 0,
                    new AsyncCallback(ReceiveTCPCallback), this);
            }
            catch (SocketException se)
            {
                log.Error("Error receiving, closing connection.", se);
                Stop();
                return;
            }
        }

        private static void ReceiveTCPCallback(IAsyncResult ar)
        {
            // Retrieve the state object and the client socket 
            // from the async state object.
            Connection client = (Connection)ar.AsyncState;
            lock (client.tcpSocket)
            {
                if (client.tcpSocket == null)
                    return;

                int bytesRead;
                try
                {
                    // Read data from the remote device.
                    bytesRead = client.tcpSocket.EndReceive(ar);
                }
                catch (SocketException se)
                {
                    client.log.Error("Error reading, closing connection.", se);
                    client.Stop();
                    return;
                }
                client.tcpOffset += bytesRead;

                while (client.tcpOffset > MessageTypeMap.MessageLengthLength)
                {
                    int expected_length = BitConverter.ToInt32(client.tcpbuffer, 0);

                    if (client.tcpOffset >= expected_length)
                    {
                        IMessage message;
                        try
                        {
                            message = (IMessage)CustomFormatter.Deserialize(client.tcpbuffer, MessageTypeMap.MessageLengthLength);
                        }
                        catch (Exception e)
                        {
                            client.log.Error("Invalid packet received, closing connection.", e);
                            client.Stop();
                            return;
                        }
                        if (client.messageInQueue.TryAdd(message))
                        {
                            client.log.Trace("enqueued " + message.GetType() + " message");
                            if (client.MessageRecieved != null) client.MessageRecieved(client, new MessageEventArgs(message));
                        }
                        else
                        {
                            client.log.Error("Failed to enqueue " + message.GetType() + " message");
                        }

                        // copy the remaining data to the front of the buffer
                        client.tcpOffset -= expected_length;
                        if (client.tcpOffset > 0)
                            Array.Copy(client.tcpbuffer, expected_length, client.tcpbuffer, 0, client.tcpOffset);
                    }
                }

                // listen for the next message
                try
                {
                    client.tcpSocket.BeginReceive(client.tcpbuffer, client.tcpOffset, MessageTypeMap.BufferSize - client.tcpOffset, 0,
                        new AsyncCallback(ReceiveTCPCallback), client);
                }
                catch (SocketException se)
                {
                    client.log.Error("Error receiving, closing connection.", se);
                    client.Stop();
                    return;
                }
            }
        }

        public void Send(IMessage message)
        {
            if (!messageOutQueue.TryAdd(message))
            {
                log.Error("Failed to enqueue " + message.GetType() + " message");
            }
        }

        private void BeginSending()
        {
            IMessage message;
            if (!messageOutQueue.TryTake(out message))
                return;

            byte[] buffer;
            try
            {
                // Custom serialization
                buffer = CustomFormatter.Serialize(message);
            }
            catch (Exception e)
            {
                log.Error("Invalid message to serialize, closing connection.", e);
                Stop();
                return;
            }

            lock (tcpSocket)
            {
                if (tcpSocket == null || !tcpSocket.Connected)
                {
                    log.Error("Tried to send message " + message + " while not connected.");
                    return;
                }

                try
                {
                    tcpSocket.BeginSend(buffer, 0, buffer.Length, 0,
                        new AsyncCallback(SendTCPCallback), this);
                }
                catch (SocketException se)
                {
                    log.Error("Error sending, closing connection", se);
                    Stop();
                    return;
                }
            }
        }

        private static void SendTCPCallback(IAsyncResult ar)
        {
            Connection client = (Connection)ar.AsyncState;
            lock (client.tcpSocket)
            {
                if (client.tcpSocket == null)
                {
                    client.log.Error("Socket closed while sending");
                    return;
                }

                try
                {
                    // Complete sending the data to the remote device.
                    client.tcpSocket.EndSend(ar);
                }
                catch (SocketException se)
                {
                    client.log.Error("Error while sending, closing connection", se);
                    client.Stop();
                }
            }
            client.BeginSending();
        }

        public IMessage PopNextMessage()
        {
            IMessage message;
            if (!messageInQueue.TryTake(out message))
                log.Info("In queue of messages exhausted");
            return message;
        }
    }
}
