using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using Microsoft.FSharp.Collections;
using Microsoft.FSharp.Core;
using UpdateControls;
using System.Linq;

namespace Strive.Client.Model
{
    public class RecordedMapModel<TKeyType, TValueType> : IEnumerable<TValueType>
    {
        // TODO: choose a better data-structure for the history
        public readonly List<FSharpMap<TKeyType, TValueType>> History = new List<FSharpMap<TKeyType, TValueType>>();

        public int CurrentVersion { get; private set; }
        public RecordedMapModel()
        {
            Clear();
        }

        private FSharpMap<TKeyType, TValueType> Map
        {
            get
            {
                return History.First();
            }
            set
            {
                // TODO: store the version number with the item
                ++CurrentVersion;
                History.Add(value);
            }
        }

        public RecordedMapModel(IEnumerable<KeyValuePair<TKeyType, TValueType>> keyValuePairs)
        {
            Contract.Requires<ArgumentNullException>(keyValuePairs != null);

            foreach (var e in keyValuePairs)
                Map = Map.Add(e.Key, e.Value);
        }

        #region Independent properties
        // Generated by Update Controls --------------------------------
        private readonly Independent _indEntities = new Independent();

        public void Set(TKeyType key, TValueType value)
        {
            _indEntities.OnSet();
            Map = Map.Add(key, value);
        }

        public void Remove(TKeyType key)
        {
            _indEntities.OnSet();
            Map.Remove(key);
        }

        public TValueType Get(TKeyType id)
        {
            _indEntities.OnGet();
            var option = Map.TryFind(id);
            return option == FSharpOption<TValueType>.None ? default(TValueType) : option.Value;
        }

        public IEnumerable<TValueType> Values
        {
            get { _indEntities.OnGet(); return Map.Select(x=>x.Value); }
        }

        public int Count
        {
            get { _indEntities.OnGet(); return Map.Count; }
        }

        public void Clear()
        {
            _indEntities.OnSet();
            Map = new FSharpMap<TKeyType, TValueType>(Enumerable.Empty<Tuple<TKeyType, TValueType>>());
        }

        public bool ContainsKey(TKeyType key)
        {
            _indEntities.OnGet();
            return Map.ContainsKey(key);
        }

        // End generated code --------------------------------
        #endregion

        #region IEnumerable<TValueType> Members

        public IEnumerator<TValueType> GetEnumerator()
        {
            return Map.Select(x=>x.Value).GetEnumerator();
        }

        #endregion

        #region IEnumerable Members

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            // TODO: make an extension Values method for FSharpMap?
            return Map.Select(x=>x.Value).GetEnumerator();
        }

        #endregion
    }
}
